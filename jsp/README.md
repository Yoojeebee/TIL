### <strong>서블릿(Servlet)</strong>  
서블릿은 클라이언트 웹 브라우저를 통해 요청하면 서버에서 실행한 후 결과값만 클라이언트로 전송한다. 또한, HTTP 프로토콜로 통신하는 웹의 특징과 속성들을 자유롭게 활용할 수 있는 API를 제공함으로써, 클라이언트의 요청과 서버의 응답에 관한 처리 작업을 쉽게 할 수 있다.  
서블릿의 기존의 CGI(Common Gateway Interface)가 가지던 성능적 약점, 메모리 문제, 단일 인스턴스로 인한 병목현상 등을 해결  
<br/>

### <strong>JSP(Java Server Page)</strong>  
서블릿과 똑같은 기능을 가지고 있지만 차이가 있다면 표현하는 방법과 웹 어플리케이션에서의 역할이 다르다.  
첫 번째는 서블릿은 완벽하게 자바 언어로 구현해야 하지만, JSP HTML 페이지 안에서 스크립트 형태로 구현한다. 또한, 일부 서블릿 객체는 변수 선언과 초기화 작업 없이 바로 사용해서 코드가 훨씬 간단히 할 수 있다. 내부적으로 자동으로 코드가 생성되기 때문이다.  
두 번째는 웹 어플리케이션에서의 역할이 다른데, 서블릿은 컨트롤러(Controller) 페이지를 만들 때 사용하지만, JSP는 뷰(view) 페이지를 만들 때 사용. 뷰는 단순히 클라이언트가 보는 화면으로써 클라이언트로부터 요청받거나 처리된 결과를 보여주는 페이지이다. 뷰에서 들어온 요청을 받아서 처리하는 페이지가 컨트롤러 페이지이며, 이는 서블릿으로 구현.  
<br/>

### <strong>웹서버</strong>  
웹에서 서버 기능을 수행하는 프로그램으로써 HTTP라는 프로토콜을 기반으로 하여 웹 클라이언트(브라우저)로부터의 요청을 서비스하는 기능을 담당합니다. HTTP라는 프로토콜을 기반으로 동작하므로 웹서버를 HTTP서버라고도 한다. 웹 서버의 역할은 클라이언트로부터 요청을 받는 일과 처리된(서비스) 결과를 클라이언트로 응답하는 일로 나뉘며, 구체적으로 다음 기능들을 처리.  
1. 클라이언트가 요청한 웹 문서를 찾아서 전달하는 기능을 처리
2. 요청 파일이 없거나 문제가 발생하면 정해진 코드 값으로 응답
3. 클라이언트로부터 요청에 대한 기본 사용자 인증(Basic Authentication)을 처리
4. 서버 프로그램에 대한 요청을 웹 어플리케이션 서버에 수행시키고 그 결과를 응답  
<br/>

### <strong>웹 애플리케이션 서버</strong>  
웹 서버에서는 클라이언트로부터의 요청을 다양한 목적으로 서비스하기 위해 HTTP뿐만 아니라 다양한 형식의 문서와 웹 애플리케이션을 처리. 그런데 여러 웹 클라이언트로부터의 요구를 웹서버 단독으로 처리하면 서버의 처리량이 많아지고 속도 및 보안 같은 성능 문제가 생긴다. 또한, C/S(Client/Server) 환경을 모두 필요로 할 때는 웹 기반의 요청과 C/S 환경 기반의 요청을 각각 개별적으로 처리하도록 구축하여야 한다.  
이러한 이유로 여러 개의 서버를 병렬로 처리하는 방법을 쓰기도 하지만, 웹 서버의 기능을 분리해서 처리하려는 목적으로 웹 애플리케이션 서버(Web Application Server)를 사용. 클라이언트로부터 요청받은 일과 화면에 표현하는 로직(Presentation Logic)까지만 웹 서버에서 담당하고, 다양한 기능을 수행하는 로직(Business Logic)은 컨테이너가 담당하도록 WAS에서 일을 나우어 역할을 분담하는 것.  
WAS는 크게 웹 서버 기능과 컨테이너 기능으로 구성되며 대부분 상용화된 WAS는 웹 서버나 커넽이너 기능 외에 엔터프라이즈 환경에서 필요한 트랜잭션, 보안, 트래픽 관리, DB 커넥션 풀, 사용자 관리 등의 다양하고 강력한 기능을 제공. 즉, Java EE 기술을 서버로서 웹서버 기능에 서블릿/JSP 컨테이너 그리고 EJB 컨테이너 기능까지 지원하는 서버를 제공. 그래서 WAS를 Java EE 서버라고도 한다.  
<br/>

### <strong>컨테이너</strong>  
서블릿과 JSP와 같은 웹서버 애플리케이션들은 동적 콘텐츠를 생성하는 웹 컴포넌트이다. 이러한 웹 컴포넌트를 저장하는 저장소 역할, 메모리 로딩, 객체 생성 및 초기화 등 서블릿의 생명주기를 관리하고 JSP를 서블릿으로 변환하는 기능을 수행하는 프로그램이 바로 컨테이너.  

1. <strong>서블릿 컨테이너</strong>  
   클라이언트 요청에 따라 서블릿을 수행하는 프로그램. 서블릿 수행에 대한 내부적인 루틴은 컨테이너의 종류마다 다르지만(JBoss, Tomcat, Jeus 등), 오라클에서 제시하고 있는 서블릿 컨테이노서의 기본 스펙들을 지원한다. 또한, 서블릿 표준 API에서 제공하는 추상 클래스와 인터페이스를 구현한 클래스를 제공하여 기본적인 동작 방식과 API 호환성을 지원. 따라서 다른 서블릿 컨테이너를 기반으로 개발하더라도 또 다른 컨테이너를 기반으로 수행 및 유지보수를 할 수 있다. 다만, 사용하려는 서블릿 컨테이너가 서블릿의 어떤 버전을 지원하는가에 따라서 구현 시 사용되는 API 스펙은 달라진다.  
    <br/>
2. <strong>JSP 컨테이너</strong>  
   JSP를 서블릿으로 변환하는 프로그램. JSP 컨테이너 역시 서블릿으로 구현된 프로그램이며 JSP 컨테이너가 JSP 파일을 서블릿 소스로 변환할 때의 기본 스펙은 컨테이너마다 동일하며, 상속관계나 생성되는 서블릿 클래스명만 다르게 생성된다. JSP 컨테이너는 JSP 파일을 서블릿 소스로 변환 및 컴파일까지만 담당하는 프로그램이며, 변환된 서블릿의 수행은 서블릿 컨테이너가 담당.  
   <br/>
![jsp_컨테이너](https://github.com/Yoojeebee/TIL/blob/master/images/jsp컨테이너.jpg?raw=true)  
<br/>

### <strong>HTTP 프로토콜</strong>  
웹은 서버와 클라이언트로 구성되며 서로 간에 HTTP 프로토콜을 기반으로 동작. 따라서 HTTP 프로토콜에서 규정하는 서버와 클라이언트 간의 통신 방식에 대하여 이해하는 것은 웹서버 애플리케이션을 개발하고 운영하는 데 도움이 된다.  

1. <strong>HTTP란?</strong>  
   HTTP(Hyper Text Transfer Protocol) TCP/IP 4계층에서 애플리케이션 계층(Application Layer)에 해당하는 프로토콜로써, 전송 계층(Transport Layer)에서 TCP를 사용하여 웹 브라우저와 웹 서버 간에 통신하는 프로로톨이다. HTTP는 웹 브라우저와 웹 서버가 통신(요청, 응답)할 때 서로 약속된 요청, 응답 메세지를 주고받으면서 통신이 이루어진다.  
   HTTP는 신뢰성 있는 통신과 처리 효율이 높은 프로토콜서 인터넷 환경에서 가장 적합한 통신구조 인정받았으며 다음과 같은 특징이 있다.  
   <br/>
- <strong>무연결(Connectionless)</strong>  
  일적으로 클라이언트가 서버와 통신하려면 연결을 유지한 상태에서 통신해야 한다. 그러나 HTTP는 연결을 유지하지 않은 상태로 데이터를 주고받을 수 있으며 HTTP는 클라이언트로부터 요청이 들어와 서버가 응답하면 클라이언트와 서버 연결을 끊고 클라아이언트가 새로 요청하면 또 다른 연결을 맺는다. 이때의 연결은 이전과는 아무 상관이 없는 새로운 연결이다.  
  즉, HTTP는 클라이언트와 서버간에 요청이 있을 때마다 독립적으로 연결하여 통신하는 방식이다. 그래서 클라이언트와 서버의 요청 단위로 새로운 연결을 처리해야 하는 단점이 있다.  
  <br/>

- <strong>무상태(Stateless)</strong>  
  HTTP는 무연결 특징이 있어서 요청이 있을 때마다 독립적인 트랜잭션으로 취급하기 때문에 이전 연결에서 했던 작업내용을 다음 요청에서 그대로 사용할 수 없다. 이처럼 요청마다 서로 다른 연결로 인식되어 요처 간에 정보를 공유해서 사용할 수 없는 상태, 즉 상태정보가 유지되지 않는 특성을 무상태(Stateless)라고 한다.  
  그래서 HTTP를 사용한는 웹 프로그래밍에서는 이전 요청 시 사용한 정보를 다른 요청에서도 계속 사용하고 싶다면, 서버나 클라이언트 측에 정보를 저장해 두고 계속 상태정보를 유지한 후 사용하는 정보 유지기술이 필요하다.  
  <br/>

- <strong>요청, 응답(Request, Response)</strong>  
  클라이언트가 서비스를 요청하면 서비스 요청 정보를 받고 요청을 처리한 후 응답함으로써 서비스가 완료되는 방식, 즉 요청정보와 응답정보를 주고받으며 통신이 이루어지는 방식을 요청, 응답 또는 request-reply라고 한다. HTTP가 대표적인 요청, 응답 방식이다.  
  HTTP는 웹 클라이언트가 서버에 TCP 접속을 처리한 후에 요청 메세지를 보내면, 웹서버는 요청 메세지를 근거로 서비스를 처리한 다음, 그 결과이 응답 메세지를 클라이언트에 보냄으로써 통신한다. 그래서 웹서버 프로그래밍을 하려면 웹서버와 클라이언트가 요청 및 응답 메세지에 대한 이해가 이루어져야 한다.  
  <br/>

2. <strong>HTTP 요청정보</strong>  
   HTTP 요청정보는 웹 클라이언트가 웹서버에 서비스를 요청하면 HTTP에 의하여 자동으로 만들어져 서비스를 요청받는 웹서버에 전달된다. 웹 클라이언트가 서비스를 요청한다는 것은 웹 브라우저 주소줄에 URL을 입력한 후 엔터 키를 누르거나 웹 브라우저 화면의 링크 또는 버튼을 클릭하는 동작을 말하며, 웹 브라우저에게 이러한 액션이 일어나면 HTTP는 요청정보를 생성하여 웹서버에 전달함으로써 서비스 요청이 이루어진다. 아래의 그림은 서비스 요청시 전달되는 HTTP 요청정보를 그림으로 나타낸 것이다.  
   <br/>
   ![http](https://github.com/Yoojeebee/TIL/blob/master/images/httpInfo.jpg?raw=true)  
   <br/>

- <strong>HTTP 요청방식</strong>  
  1. <strong>GET</strong>  
  웹 서버에 GET 방식으로 서비스를 요청하는 경우는 웹 브라우저 주소 줄에 URL을 직접 입력하거나 하이퍼링크가 포함된 개체를 클릭할 때. 또는 직접 GET 방식을 지정하여 서비스를 요청할 수도 있따. GET 방식의 요청은 브라우저에게 캐시(cache)가 가능하며 클라이언트가 서버로 전송하는 문자열이 있을 때는 요청정보 헤더의 요청 줄에 포함되는 URL 뒤에 `?` 기호와 함께 추가되어 전달된다. 그래서 클라이언트에서 서버로 보내는 모든 문자열 정보들이 웹 브라우저에 노출되는 특징이 있으며, 헤더에 포함되므로 전달되는 문자열의 크기에 제한이 있다. GET은 가장 단순한 요청방식으로 서버에 빠른 속도로 요청할 때 사용.  
  <br/>

  2. <strong>POST</strong>  
  POST 방식은 데이터가 HTTP 요청정보의 몸체에 포함되어 전달된다. 따라서 데이터 크기에 제한이 없고, 화면에 노출되지 않는다. 그러나 POST 방식은 웹 클라이언트 측에서 보내는 데이터를 인코딩하고, 서버 측에서 디코딩해야 하므로 GET 방식보다 상대적으로 처리속도가 느리다. POST 방식은 주로 서버 측의 정보를 새로 생성하는 작업에 사용된다.  
  <br/>

  3. <strong>DELETE</strong>  
  서버의 리소스를 삭제하는 작업을 요처할 때 사용하는 방식.  
  <br/>

  4. <strong>OPTIONS</strong>  
  요청 URI에 대하여 허용되는 통신 옵션을 알고자 할 때 사용하는 방식.  
  <br/>

  5. <strong>HEAD</strong>
  GET 방식과 같으나 요청정보의 몸체 없이 헤더 정보만 요청하는 방식. 해당 자원이 존재하는지 또는 서버에 문제가 있는지를 확인하기 위해 사용.  
  <br/>

  6. <strong>TRACE</strong>  
  웹 클라이언트 요청을 그대로 반환하는 방식으로 요청 정보가 웹서버에 도달하기까지의 경로를 기록. TRACE 방식은 ECHO 서비스로 서버 상태를 확인하기 위한 목적으로 사용.  
  <br/>

  7. <strong>CONNECT</strong>  
  프락시(Proxy)에 사용하기 위해 예약된 메소드로서 프락시가 동적으로 접속할 수 있게 지원.  
  <br/>

- <strong>요청 URI</strong>  
  웹 클라이언트가 웹서버에 요청한 서비스 문서의 정보. 네트워크 자원정보인 URL의 일부로서 URL(Uniform Resource Locator)은 네트워크상에 존재하는 자원을 찾아가기 위한 정보.  
  ```HTML
  프로토콜 서버주소 포트번호 서버자원정보(Request-URI)
  ```  
  <br/>

  1. <strong>프로토콜</strong>  
  서버와 통신하기 위한 규약으로써 서버마다 사용하는 프로토콜이 정해져 있따. 예를 들어, 웹서버는 URL에 `http://`로 표현하며 오라클 DBMS는 `jdbc:oracle:thin:@`으로 표현한다.  
  <br/>

  2. <strong>서버 주소</strong>  
  네트워크상에서 연결된 컴퓨터를 찾아가기 위한 정보로서 IP주소 또는 도메인 이름으로 표현한다. 서버가 동작하고 있는 컴퓨터의 정보.  
  <br/>

  3. <strong>포트 번호</strong>  
  URL에서 서버 주소를 이용해 컴퓨터를 찾았다면 포트 번호는 컴퓨터에서 동작하고 있는 서버로 접속하기 위한 정보. 포트 번호는 0 ~ 65,535번까지 사용할 수 있으며, 0 ~ 1,023 사이의 번호는 well-known 포트(port)로서 이미 사용이 정의되어 있다. 예를 들어, 웹서버가 사용하는 포트 번호는 80번으로 URL에서 HTTP 프로토콜로 접속 시 포트 번호를 생략하면 자동으로 80번 포트로 인식. 80번 port 이외의 포트 번호를 웹서버에 할당했을 시 반드시 URL에 명시.  
  <br/>

  4. <strong>URI(Uniform Resource Identifier)</strong>  
  서버에서 서비스하는 서버의 자원 정보. URI에서 포트 번호 다음부터가 URI이다. 예를 들어  
      ```HTML
      http://www.mysite.com:80/edu/index.html
      ```  
      80 다음부터인 /edu/... 부터는 접속한 서버에서 제공하는 자원정보로써 이것을 URI라고 한다.  
      <br/>
  

- <strong>헤더</strong>  
header는 general-header, request-header, entity-header 3가지로 분류할 수 있으며, 클라이언트의 요청에 따라 필요한 헤더만 사용된다. 헤더에는 `name : content`의 형식으로 정보들이 표현되며 content 부분의 값들은 공백이나 탭으로 구분된다. 아래의 표는 요청정보 헤더의 필드이름과 값들이다.  

  ![header](https://github.com/Yoojeebee/TIL/blob/master/images/header.jpg?raw=true)  
  <br/>

  1. <strong>Accept</strong>  
  클라이언트가 인식하여 처리할 수 있는 파일 타입을 명시. 여러 개의 파일 타입은 쉼표(,)로 구분하여 나열.  
  <br/>

  2. <strong>Accept-Encoding</strong>  
  compress 또는 gzip과 같은 웹 클라이언트가 받아들일 수 있는 인코딩 방식을 지정. 여러 개의 인코딩 방식을 쉼표(,)로 구분하여 나열. 만약 인코딩 형태를 지정하지 않으면 클라이언트에 어떤 형태도 받아들여지지 않는다.  
  <br/>

  3. <strong>Accept-Language</strong>
  클라이언트가 지원하는 언어를 지정.

  4. <strong>User-Agent</strong>  
  클라이언트가 사용하는 웹 브라우저에 대한 정보를 보여준다. 서버 쪽에서는 User-Agent 정보를 보고 일반 웹페이지와 모바일 웹페이지로 자동 분기한다.  
  <br/>

  5. <strong>Cache-Control</strong>  
  HTTP 캐시는 클라이언트가 서버에 요청하여 응답받은 서비스 결과를 클라이언트 쪽에 저장했다가 사용자로부터 같은 서비스 요청이 들어오면 이전에 저장된 처리결과를 보여주는 것을 말한다. 캐시는 클라이언트와 서버 사이에서 발생하는 작업을 생략함으로써 트랙픽을 줄이고, 클라이언트는 응답을 빠르게 받을 수 있는 장점이 있다. Cache-Control은 다음과 같은 값을 설정할 수 있다.  
  
  - no-cache: 캐시 안함
  - no-store: 신속히 넘긴 후 정보 제거
  - max-age = seconds: 지정된 시간보다 오래된 데이터는 캐시 안 함
  - max-stale = seconds: 지정된 시간이 아직 되지 않은 만료된 데이터를 보냄
  - min-fresh = seconds: 지정된 시간 이후의 변경된 새로운 데이터만 보냄
  - only-if-cached: 새로운 데이터를 검색하지 않고 캐시에 있는 데이터만 반환  
<br/>

- <strong>HTTP 응답정보</strong>  
웹서버에서 클라이언트로 보내지는 응답정보 메세지의 구조.  
<br/> 
![header](https://github.com/Yoojeebee/TIL/blob/master/images/header.jpg?raw=true)  
<br/>

  HTTP 응답정보의 상태 줄은 HTTP 버전, 상태 코드(Status-Code), 상태 코드 설명(Reason-Phrase)으로 구성되어 있다. HTTP 버전은 서버가 응답하기 위해 사용하는 HTTP 버전 정보이고, 상태 코드는 요청한 처리 결과를 숫자 세 자리로 나타내며, 상태 코드 설명은 처리 결과를 이해하기 쉬운 텍스트로 표현한 것.  


  1. <strong>상태 코드</strong>  
  클라이언트 요청에 대한 처리 결과를 의미. 클라이언트(웹 브라우저)는 응답정보 메시지를 받으면 상토 코드(Status code)를 보고 처리 결과인 응답정보 메시지를 처리한다. 상태코드는 3자리 숫자로 표현하며 가장 앞자리 숫자를 기준으로 응답정보 처리 결과를 분류할 수 있다. 1xx는 조건부 응답, 2xx는 성공, 3xx는 리다이렉션 완료, 4xx는 요청 오류, 5xx는 서버 오류에 관한 상태 코드.

  - <strong>200 OK</strong>  
  클라이언트 요청을 성공적으로 처리했음을 나타내며, 서버는 요청한 데이터를 포함하여 응답한다. 응답 메시지는 요청한 요청방식에 따라 다르게 전달  
  <br/>

  - <strong>400 Bad Request</strong>  
  클라이언트 요청에 문법적인 오류 등 잘못된 요청으로 서버가 요청을 해석할 수 없는 경우이다. 이런 경우는 잘못된 요청 형식을 수정하여 다시 요청해야 한다.  
  <br/>  

  - <strong>401 Unauthorized</strong>  
  인증 오류(Unauthorized)로서 클라이언트가 잘못된 인증 정보를 Authorization 헤더에 넣었음을 나타낸다. 이런 경우 클라이언트는 요청정보 헤더의 Authorization에 적절한 인증 정보를 설정한 후 다시 요청해야 한다.  
  <br/>

  - <strong>403 Forbidden</strong>  
  사용자 허가 모드 오류(Forbidden)로서 클라이언트의 인증 정보에 상관없이 페이지에 대한 접근을 거부한다는 것을 나타낸다.  
  <br/>

  - <strong>404 Not Found</strong>  
  클라이언트가 요청한 문서가 존재하지 않음을 의미. 즉, 클라이언트의 요청에 대하여 서비스하는 요청 URI를 서버가 찾지 못한 경우.  
  <br/>

  - <strong>405 Method Not Allowed</strong>  
  클라이언트가 요청한 서비스 요청방식을 웹서버에서 지원하지 않음을 의미. 이런 경우는 요청한 서비스 요청방식을 확인한 후 서버 프로그램에서 해당 요청방식 처리 메소드가 구현되었는지를 확인.  
  <br/>

  - <strong>500 Internal Server Error</strong>  
  서버 프로그램 실행 시 오류가 발생하여 서버 프로그램이 실행을 멈추었거나 올바르지 않은 응답 헤더 정보가 설정되었을 때 발생. 일반적으로 서버 프로그램 실행 오류가 많으며, 이런 경우 서버 프로그램 내에서 구현의 오류를 찾아 수정.  
  <br,/>

  2. <strong>헤더</strong>